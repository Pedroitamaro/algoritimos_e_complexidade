# Aulas 09-12: Árvores e Grafos

## Aula 09: Árvore Binária de Busca

**Objetivos:** Compreender conceitos de árvores binárias, implementar BST, dominar operações básicas.

### Conceitos Fundamentais
- **Árvore:** Estrutura hierárquica com nós conectados
- **Árvore Binária:** Cada nó tem no máximo 2 filhos
- **BST:** Propriedade de ordenação (esquerda < raiz < direita)

### Implementação Básica
```c
#include <stdio.h>
#include <stdlib.h>

typedef struct No {
    int data;
    struct No *esquerda, *direita;
} No;

No* criar_no(int data) {
    No *novo = malloc(sizeof(No));
    novo->data = data;
    novo->esquerda = novo->direita = NULL;
    return novo;
}

No* inserir(No *raiz, int data) {
    if (raiz == NULL) return criar_no(data);
    
    if (data < raiz->data)
        raiz->esquerda = inserir(raiz->esquerda, data);
    else if (data > raiz->data)
        raiz->direita = inserir(raiz->direita, data);
    
    return raiz;
}

No* buscar(No *raiz, int data) {
    if (raiz == NULL || raiz->data == data)
        return raiz;
    
    if (data < raiz->data)
        return buscar(raiz->esquerda, data);
    
    return buscar(raiz->direita, data);
}

No* encontrar_minimo(No *no) {
    while (no->esquerda != NULL)
        no = no->esquerda;
    return no;
}

No* remover(No *raiz, int data) {
    if (raiz == NULL) return raiz;
    
    if (data < raiz->data)
        raiz->esquerda = remover(raiz->esquerda, data);
    else if (data > raiz->data)
        raiz->direita = remover(raiz->direita, data);
    else {
        // Nó a ser removido encontrado
        if (raiz->esquerda == NULL) {
            No *temp = raiz->direita;
            free(raiz);
            return temp;
        } else if (raiz->direita == NULL) {
            No *temp = raiz->esquerda;
            free(raiz);
            return temp;
        }
        
        // Nó com dois filhos
        No *temp = encontrar_minimo(raiz->direita);
        raiz->data = temp->data;
        raiz->direita = remover(raiz->direita, temp->data);
    }
    return raiz;
}
```

### Complexidade
- **Busca/Inserção/Remoção:** O(h) onde h é altura
- **Melhor caso:** O(log n) - árvore balanceada
- **Pior caso:** O(n) - árvore degenerada

---

## Aula 10: Percurso em Árvores Binárias

**Objetivos:** Dominar algoritmos de travessia, implementar versões recursivas e iterativas.

### Tipos de Percurso

#### 1. Em Ordem (In-order)
```c
void inorder(No *raiz) {
    if (raiz != NULL) {
        inorder(raiz->esquerda);
        printf("%d ", raiz->data);
        inorder(raiz->direita);
    }
}
```

#### 2. Pré-ordem (Pre-order)
```c
void preorder(No *raiz) {
    if (raiz != NULL) {
        printf("%d ", raiz->data);
        preorder(raiz->esquerda);
        preorder(raiz->direita);
    }
}
```

#### 3. Pós-ordem (Post-order)
```c
void postorder(No *raiz) {
    if (raiz != NULL) {
        postorder(raiz->esquerda);
        postorder(raiz->direita);
        printf("%d ", raiz->data);
    }
}
```

#### 4. Por Nível (Level-order)
```c
#include <queue>

void levelorder(No *raiz) {
    if (raiz == NULL) return;
    
    queue<No*> q;
    q.push(raiz);
    
    while (!q.empty()) {
        No *atual = q.front();
        q.pop();
        
        printf("%d ", atual->data);
        
        if (atual->esquerda) q.push(atual->esquerda);
        if (atual->direita) q.push(atual->direita);
    }
}
```

### Percurso Iterativo com Pilha
```c
void inorder_iterativo(No *raiz) {
    if (raiz == NULL) return;
    
    No **pilha = malloc(1000 * sizeof(No*));
    int topo = -1;
    No *atual = raiz;
    
    while (atual != NULL || topo >= 0) {
        while (atual != NULL) {
            pilha[++topo] = atual;
            atual = atual->esquerda;
        }
        
        atual = pilha[topo--];
        printf("%d ", atual->data);
        atual = atual->direita;
    }
    
    free(pilha);
}
```

---

## Aula 11: Balanceamento de Árvore e Árvore AVL

**Objetivos:** Compreender problemas de desbalanceamento, implementar árvores AVL.

### Conceitos de Balanceamento
- **Fator de Balanceamento:** altura(direita) - altura(esquerda)
- **Árvore AVL:** |fator de balanceamento| ≤ 1 para todos os nós

### Rotações

#### Rotação Simples à Direita
```c
No* rotacao_direita(No *y) {
    No *x = y->esquerda;
    No *T2 = x->direita;
    
    // Rotação
    x->direita = y;
    y->esquerda = T2;
    
    // Atualizar alturas
    y->altura = max(altura(y->esquerda), altura(y->direita)) + 1;
    x->altura = max(altura(x->esquerda), altura(x->direita)) + 1;
    
    return x;
}
```

#### Rotação Simples à Esquerda
```c
No* rotacao_esquerda(No *x) {
    No *y = x->direita;
    No *T2 = y->esquerda;
    
    // Rotação
    y->esquerda = x;
    x->direita = T2;
    
    // Atualizar alturas
    x->altura = max(altura(x->esquerda), altura(x->direita)) + 1;
    y->altura = max(altura(y->esquerda), altura(y->direita)) + 1;
    
    return y;
}
```

### Inserção AVL
```c
No* inserir_avl(No *no, int chave) {
    // Inserção normal de BST
    if (no == NULL) return criar_no(chave);
    
    if (chave < no->data)
        no->esquerda = inserir_avl(no->esquerda, chave);
    else if (chave > no->data)
        no->direita = inserir_avl(no->direita, chave);
    else
        return no;
    
    // Atualizar altura
    no->altura = 1 + max(altura(no->esquerda), altura(no->direita));
    
    // Obter fator de balanceamento
    int balance = obter_balance(no);
    
    // Casos de rotação
    // Esquerda Esquerda
    if (balance > 1 && chave < no->esquerda->data)
        return rotacao_direita(no);
    
    // Direita Direita
    if (balance < -1 && chave > no->direita->data)
        return rotacao_esquerda(no);
    
    // Esquerda Direita
    if (balance > 1 && chave > no->esquerda->data) {
        no->esquerda = rotacao_esquerda(no->esquerda);
        return rotacao_direita(no);
    }
    
    // Direita Esquerda
    if (balance < -1 && chave < no->direita->data) {
        no->direita = rotacao_direita(no->direita);
        return rotacao_esquerda(no);
    }
    
    return no;
}
```

---

## Aula 12: APS (Grafos) - Conceitos e Representação

**Objetivos:** Compreender conceitos básicos de grafos, implementar representações.

### Definições Básicas
- **Grafo:** G = (V, E) onde V são vértices e E são arestas
- **Grafo Direcionado:** Arestas têm direção
- **Grafo Não-Direcionado:** Arestas bidirecionais
- **Peso:** Valor associado à aresta

### Representação por Matriz de Adjacência
```c
#define MAX_VERTICES 100

typedef struct {
    int matriz[MAX_VERTICES][MAX_VERTICES];
    int num_vertices;
} GrafoMatriz;

void inicializar_matriz(GrafoMatriz *g, int vertices) {
    g->num_vertices = vertices;
    for (int i = 0; i < vertices; i++) {
        for (int j = 0; j < vertices; j++) {
            g->matriz[i][j] = 0;
        }
    }
}

void adicionar_aresta_matriz(GrafoMatriz *g, int origem, int destino) {
    g->matriz[origem][destino] = 1;
    g->matriz[destino][origem] = 1; // Para grafo não-direcionado
}

void imprimir_matriz(GrafoMatriz *g) {
    for (int i = 0; i < g->num_vertices; i++) {
        for (int j = 0; j < g->num_vertices; j++) {
            printf("%d ", g->matriz[i][j]);
        }
        printf("\n");
    }
}
```

### Representação por Lista de Adjacência
```c
typedef struct NoLista {
    int vertice;
    struct NoLista *proximo;
} NoLista;

typedef struct {
    NoLista **listas;
    int num_vertices;
} GrafoLista;

GrafoLista* criar_grafo_lista(int vertices) {
    GrafoLista *g = malloc(sizeof(GrafoLista));
    g->num_vertices = vertices;
    g->listas = malloc(vertices * sizeof(NoLista*));
    
    for (int i = 0; i < vertices; i++) {
        g->listas[i] = NULL;
    }
    
    return g;
}

void adicionar_aresta_lista(GrafoLista *g, int origem, int destino) {
    // Adiciona destino à lista de origem
    NoLista *novo = malloc(sizeof(NoLista));
    novo->vertice = destino;
    novo->proximo = g->listas[origem];
    g->listas[origem] = novo;
    
    // Para grafo não-direcionado, adiciona origem à lista de destino
    novo = malloc(sizeof(NoLista));
    novo->vertice = origem;
    novo->proximo = g->listas[destino];
    g->listas[destino] = novo;
}

void imprimir_lista(GrafoLista *g) {
    for (int i = 0; i < g->num_vertices; i++) {
        printf("Vértice %d: ", i);
        NoLista *atual = g->listas[i];
        while (atual) {
            printf("%d -> ", atual->vertice);
            atual = atual->proximo;
        }
        printf("NULL\n");
    }
}
```

### Algoritmos Básicos de Busca

#### DFS (Busca em Profundidade)
```c
void dfs_util(GrafoLista *g, int vertice, int *visitado) {
    visitado[vertice] = 1;
    printf("%d ", vertice);
    
    NoLista *atual = g->listas[vertice];
    while (atual) {
        if (!visitado[atual->vertice]) {
            dfs_util(g, atual->vertice, visitado);
        }
        atual = atual->proximo;
    }
}

void dfs(GrafoLista *g, int inicio) {
    int *visitado = calloc(g->num_vertices, sizeof(int));
    printf("DFS a partir do vértice %d: ", inicio);
    dfs_util(g, inicio, visitado);
    printf("\n");
    free(visitado);
}
```

#### BFS (Busca em Largura)
```c
void bfs(GrafoLista *g, int inicio) {
    int *visitado = calloc(g->num_vertices, sizeof(int));
    int *fila = malloc(g->num_vertices * sizeof(int));
    int frente = 0, tras = 0;
    
    visitado[inicio] = 1;
    fila[tras++] = inicio;
    
    printf("BFS a partir do vértice %d: ", inicio);
    
    while (frente < tras) {
        int vertice_atual = fila[frente++];
        printf("%d ", vertice_atual);
        
        NoLista *atual = g->listas[vertice_atual];
        while (atual) {
            if (!visitado[atual->vertice]) {
                visitado[atual->vertice] = 1;
                fila[tras++] = atual->vertice;
            }
            atual = atual->proximo;
        }
    }
    
    printf("\n");
    free(visitado);
    free(fila);
}
```

### Comparação das Representações

| Aspecto | Matriz | Lista |
|---------|--------|-------|
| Espaço | O(V²) | O(V + E) |
| Verificar aresta | O(1) | O(grau) |
| Adicionar aresta | O(1) | O(1) |
| Iterar adjacentes | O(V) | O(grau) |

### Aplicações
- **Redes sociais:** Conexões entre pessoas
- **Mapas:** Caminhos entre cidades
- **Internet:** Conexões entre servidores
- **Dependências:** Ordem de execução de tarefas

## Bibliografia das Aulas 09-12

- Cormen, T.H. et al. *Introduction to Algorithms*, 4ª ed., Cap. 12, 13, 22
- Sedgewick, R. *Algorithms*, 4ª ed., Cap. 3, 4
- Skiena, S.S. *The Algorithm Design Manual*, 3ª ed., Cap. 3, 5
